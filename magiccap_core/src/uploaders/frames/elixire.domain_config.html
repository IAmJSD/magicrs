<body>
    <form>
        <label for="v_0" style="display: flex; align-items: center;">
            <input id="v_0" type="radio" name="m_domain" value="0" checked> 
            <span class="margin-left: 5px">Use elixi.re to manage my domain</span>
        </label>
        <label for="v_1" style="display: flex; align-items: center;">
            <input id="v_1" type="radio" name="m_domain" value="1"> 
            <span class="margin-left: 5px">Manage the domain used within MagicCap</span>
        </label>
    </form>

    <div id="domain_config" style="display: none;">
        <p id="info_load">
            <i>Loading domain information from elixi.re...</i>
        </p>
        <div id="domain_select" style="margin-top: 1em;"></div>
    </div>
</body>

<script>
    (function () {
        // If the DOM size changes, fire a resize event.
        const resizeObserver = new ResizeObserver(() => {
            window.parent.postMessage({
                height: document.body.scrollHeight,
            }, "*");
        });
        resizeObserver.observe(document.body);
    
        // Implement the get/set functionality of the SDK.
        const listeners = [];
        window.onmessage = e => {
            for (const ln of listeners) {
                ln(e.data.v);
            }
        };
        async function get() {
            return new Promise(resolve => {
                listeners.push(resolve);
                window.parent.postMessage({ get: true }, "*");
            });
        }
        function set(v) {
            window.parent.postMessage({ set: v }, "*");
        }

        // Get the elixi.re result.
        const elixireResponse = fetch("https://elixire-domains-list-proxy.astrids.workers.dev/").
            then(r => r.json()).catch((e) => ({err: e}));

        // Handle rendering the domain panel.
        function renderDomainPanel(v) {
            Promise.all([v, elixireResponse]).then(
                ([configValue, elixireResponse]) => {
                    if (elixireResponse.err) {
                        // Handle if elixi.re failed to load.
                        const p = document.createElement("p");
                        const span = document.createElement("span");
                        span.innerText = "Failed to load elixi.re domain information: ";
                        const code = document.createElement("code");
                        code.innerText = elixireResponse.err.toString();
                        p.appendChild(span);
                        p.appendChild(code);
                        document.getElementById("domain_config").innerHTML = p.outerHTML;
                        return;
                    }

                    // Wipe the domain config loading message.
                    document.getElementById("info_load")?.remove();

                    // Build the select menu.
                    const inputBox = document.createElement("input");
                    inputBox.value = "*";
                    const inputContainer = document.createElement("div");
                    const select = document.createElement("select");
                    let inputVisible = true;
                    const domains = Object.keys(elixireResponse.domains).sort((a, b) => {
                        a = Number(a);
                        b = Number(b);
                        if (a < b) return -1;
                        if (a > b) return 1;
                        return 0;
                    }).map(k => elixireResponse.domains[k]);
                    for (let domain of domains) {
                        // Build the option.
                        const option = document.createElement("option");

                        // Handle wildcard domains.
                        let hasWildcard = false;
                        if (domain.startsWith("*.")) {
                            hasWildcard = true;
                            domain = domain.slice(2);
                        }
                        option.dataset.hasWildcard = hasWildcard === true ? "true" : "false";
                        option.value = domain;
                        option.innerText = domain;

                        // Handle the selected option.
                        if (configValue?.endsWith(domain)) {
                            // If this has a wildcard, handle the input.
                            if (hasWildcard) {
                                inputBox.value = configValue.slice(0, -domain.length - 1);
                            } else {
                                inputVisible = false;
                            }
                            option.selected = true;
                        }

                        // Append the option.
                        select.appendChild(option);
                    }

                    // Handle when the user selects a domain.
                    select.addEventListener("change", e => {
                        const selectedOption = e.target.selectedOptions[0];
                        if (selectedOption.dataset.hasWildcard === "true") {
                            inputBox.value = "*";
                        } else {
                            inputBox.value = "";
                        }
                        inputVisible = selectedOption.dataset.hasWildcard === "true";
                        if (inputVisible) {
                            set(inputBox.value + "." + selectedOption.value);
                        } else {
                            set(selectedOption.value);
                        }
                        inputContainer.style.display = inputVisible ? "inline" : "none";
                    });

                    // Handle the input box.
                    inputBox.addEventListener("input", e => {
                        set(e.target.value + "." + select.selectedOptions[0].value);
                    });

                    // Set the initial value.
                    if (inputVisible) {
                        set(inputBox.value + "." + select.selectedOptions[0].value);
                    } else {
                        set(select.selectedOptions[0].value);
                    }

                    // Append the elements.
                    inputContainer.appendChild(inputBox);
                    inputContainer.appendChild(document.createTextNode("."));
                    inputContainer.style.display = inputVisible ? "inline" : "none";
                    const domainConfig = document.getElementById("domain_select");
                    domainConfig.innerHTML = "";
                    domainConfig.appendChild(inputContainer);
                    domainConfig.appendChild(select);
                },
            );
        }

        // Handle the radio button change.
        document.getElementById("v_0").addEventListener("change", e => {
            if (e.target.checked) {
                set(undefined);
                document.getElementById("domain_config").style.display = "none";
            }
        });
        document.getElementById("v_1").addEventListener("change", e => {
            if (e.target.checked) {
                renderDomainPanel(get());
                document.getElementById("domain_config").style.display = "block";
            }
        });

        // Do the initial render.
        get().then(v => {
            if (v) {
                renderDomainPanel(v);
                document.getElementById("domain_config").style.display = "block";
                document.getElementById("v_1").checked = true;
            }
        });
    })();
</script>    

<style>
    html, body {
        margin: 0;
        margin-left: 0.1em;
    }

    * {
        user-select: none;
    }

    input {
        border: 0;
        height: 2em;
        padding: 0.1em;
        border-radius: 0.25em;
    }

    @media (prefers-color-scheme: dark) {
        body {
            color: #fff;
        }

        input {
            background-color: #333;
            color: #fff;
        }
    }
</style>
